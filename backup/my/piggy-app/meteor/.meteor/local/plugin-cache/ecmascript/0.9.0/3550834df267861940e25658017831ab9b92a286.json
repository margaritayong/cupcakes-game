{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"meteor/meteor","imported":["Meteor"],"specifiers":[{"kind":"named","imported":"Meteor","local":"Meteor"}]},{"source":"../imports/api/goal.js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"Goal"}]},{"source":"mqtt/lib/connect","imported":["connect"],"specifiers":[{"kind":"named","imported":"connect","local":"connect"}]},{"source":"serialport","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"SerialPort"}]}],"exports":{"exported":["config","client"],"specifiers":[{"kind":"local","local":"config","exported":"config"},{"kind":"local","local":"client","exported":"client"}]}}},"options":{"filename":"server/main.js","filenameRelative":"server/main.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"useNativeAsyncAwait":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"server/main.js.map","sourceFileName":"server/main.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"main"},"ignored":false,"code":"module.export({\n  config: () => config,\n  client: () => client\n});\nlet Meteor;\nmodule.watch(require(\"meteor/meteor\"), {\n  Meteor(v) {\n    Meteor = v;\n  }\n\n}, 0);\nlet Goal;\nmodule.watch(require(\"../imports/api/goal.js\"), {\n  default(v) {\n    Goal = v;\n  }\n\n}, 1);\nlet connect;\nmodule.watch(require(\"mqtt/lib/connect\"), {\n  connect(v) {\n    connect = v;\n  }\n\n}, 2);\nlet SerialPort;\nmodule.watch(require(\"serialport\"), {\n  default(v) {\n    SerialPort = v;\n  }\n\n}, 3);\nconst Readline = SerialPort.parsers.Readline;\nconst parser = new Readline();\nvar port = new SerialPort('/dev/cu.usbmodem1431', {\n  baudRate: 9600\n});\nport.pipe(parser); // parse the data from serial into meaningful objects\n\nfunction onData(data) {\n  console.log(\"meteor onData: \" + data); // send the character over mqtt\n  // client.publish(\"led\", text);\n} // setup the callback for the parser\n// our callback function must be wrapped in Meteor.bindEnvironment to avoid Fiber errors\n\n\nparser.on('data', Meteor.bindEnvironment(onData)); // setup the callback for the port\n// Open errors will be emitted as an error event\n\nport.on('error', function (err) {\n  console.log('Error: ', err.message);\n}); // serial event\n\nfunction writeSerialData(data) {\n  var buffer = Buffer.from(data);\n  port.write(data, function (err) {\n    if (err) {\n      return console.log('Error on write: ', err.message);\n    }\n\n    console.log('meteor wrote', data);\n  });\n}\n\nfunction saveGoalInDataBase(targetGoal) {\n  Meteor.call('goals.upsert', goal);\n} // meteor\n\n\nMeteor.methods({\n  'serial.write'(pixels) {\n    // global ok?\n    var message = \"\"; // get RGB from hex data\n\n    var hexValue = rgbHex(pixels[0], pixels[1], pixels[2]);\n    message = hexValue;\n    writeSerialData(message + '|'); // write data to the port\n\n    client.publish(\"ledgrid\", message); // publish via mqtt\n  },\n\n  'send.goal'(targetGoal) {\n    console.log(\"Meteor send.goal\", targetGoal);\n    client.publish(\"targetGoal\", targetGoal); // publish via mqtt\n  }\n\n}); // MQTT\n\nconst config = {\n  mqttHost: \"mqtt://127.0.0.1\",\n  mqttPort: 1883\n};\nconst client = connect(config.mqttHost);\n\nfunction onMessage(topic, message) {\n  if (topic === \"targetGoal\") {\n    console.log(\"targetGoal\", message.toString());\n    Meteor.call('goals.upsert', targetGoal);\n  }\n} // client callback\n\n\nclient.on('message', Meteor.bindEnvironment(onMessage));\nclient.on(\"connect\", function () {\n  console.log(\"---- mqtt client connected ----\");\n  client.subscribe(\"targetGoal\"); // subscribe to the targetGoal topic\n});\nMeteor.startup(() => {// code to run on server at startup\n});","map":{"version":3,"sources":["server/main.js"],"names":["module","export","config","client","Meteor","watch","require","v","Goal","default","connect","SerialPort","Readline","parsers","parser","port","baudRate","pipe","onData","data","console","log","on","bindEnvironment","err","message","writeSerialData","buffer","Buffer","from","write","saveGoalInDataBase","targetGoal","call","goal","methods","pixels","hexValue","rgbHex","publish","mqttHost","mqttPort","onMessage","topic","toString","subscribe","startup"],"mappings":"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","file":"server/main.js.map","sourcesContent":["import { Meteor } from 'meteor/meteor';\nimport Goal from '../imports/api/goal.js'\nimport { connect } from 'mqtt/lib/connect';\nimport SerialPort from 'serialport';\n \nconst Readline = SerialPort.parsers.Readline;\nconst parser = new Readline();\nvar port = new SerialPort('/dev/cu.usbmodem1431', {\n  baudRate: 9600\n});\nport.pipe(parser);\n\n\n// parse the data from serial into meaningful objects\nfunction onData(data) {\n  console.log(\"meteor onData: \" + data);\n  \n  // send the character over mqtt\n  // client.publish(\"led\", text);\n}\n\n// setup the callback for the parser\n// our callback function must be wrapped in Meteor.bindEnvironment to avoid Fiber errors\nparser.on('data', Meteor.bindEnvironment(onData));\n\n// setup the callback for the port\n// Open errors will be emitted as an error event\nport.on('error', function(err) {\n  console.log('Error: ', err.message);\n})\n\n// serial event\nfunction writeSerialData(data) {\n  var buffer = Buffer.from(data);\n\n  port.write(data, function(err) {\n    if (err) {\n      return console.log('Error on write: ', err.message);\n    }\n    console.log('meteor wrote', data);\n  });\n\n}\n\nfunction saveGoalInDataBase(targetGoal) {\n  Meteor.call('goals.upsert', goal);\n}\n\n// meteor\nMeteor.methods({\n  'serial.write'(pixels) {\n\n    // global ok?\n    var message = \"\";\n\n    // get RGB from hex data\n    var hexValue = rgbHex(pixels[0], pixels[1], pixels[2]);\n\n    message = hexValue;\n\n    writeSerialData(message + '|'); // write data to the port\n    client.publish(\"ledgrid\", message); // publish via mqtt\n    \n  },\n  'send.goal'(targetGoal) {\n\n    console.log(\"Meteor send.goal\", targetGoal);\n    client.publish(\"targetGoal\", targetGoal); // publish via mqtt\n\n  }\n})\n\n \n// MQTT\nexport const config = {\n  mqttHost: \"mqtt://127.0.0.1\",\n  mqttPort: 1883\n};\n\nexport const client = connect(config.mqttHost);\n\nfunction onMessage(topic, message) {\n  if (topic === \"targetGoal\") {\n    console.log(\"targetGoal\", message.toString());\n    Meteor.call('goals.upsert', targetGoal);\n  }\n}\n\n// client callback\nclient.on('message', Meteor.bindEnvironment(onMessage));\n\nclient.on(\"connect\", function() {\n  console.log(\"---- mqtt client connected ----\");\n  client.subscribe(\"targetGoal\"); // subscribe to the targetGoal topic\n})\n\nMeteor.startup(() => {\n  // code to run on server at startup\n});\n"]},"hash":"3550834df267861940e25658017831ab9b92a286"}
